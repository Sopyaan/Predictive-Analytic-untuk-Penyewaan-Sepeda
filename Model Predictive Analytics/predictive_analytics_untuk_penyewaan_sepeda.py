# -*- coding: utf-8 -*-
"""Predictive Analytics untuk Penyewaan Sepeda

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MM4yx0c5gRQlfShTkR3bxLkXHgp_SLmd

# Predictive Analytics untuk Penyewaan Sepeda

## Problem Statement
Sistem penyewaan sepeda telah menjadi alternatif transportasi yang semakin populer di kota-kota besar. Namun, permintaan terhadap sepeda sangat fluktuatif dan dipengaruhi oleh berbagai faktor seperti cuaca, musim, serta hari kerja atau hari libur. Ketidakpastian ini menyulitkan operator dalam mengelola ketersediaan sepeda dan merencanakan strategi distribusi yang efisien. Dengan adanya data historis dan informasi lingkungan yang terus dikumpulkan, muncul peluang untuk membangun sistem prediktif yang dapat membantu pengambilan keputusan secara lebih akurat dan berbasis data.

Berdasarkan konteks tersebut, proyek ini berfokus pada dua pertanyaan utama:

- Bagaimana cara membangun model yang dapat memprediksi jumlah penyewaan sepeda secara akurat berdasarkan faktor-faktor seperti cuaca, musim, dan hari kerja?
- Apa saja faktor utama yang paling memengaruhi jumlah penyewaan sepeda, dan bagaimana cara mengoptimalkan model prediktif untuk menangkap hubungan tersebut secara tepat?

## Data Loading
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score

# load the dataset
url = 'https://raw.githubusercontent.com/Sopyaan/Predictive-Analytic-untuk-Penyewaan-Sepeda/refs/heads/main/Dataset/hour.csv'
bike_hour = pd.read_csv(url)
bike_hour

"""## Exploratory Data Analysis"""

bike_hour.info()

"""Dtype 'Date' dari 'Object' harus di ubah kedalam 'Datetime'"""

bike_hour['dteday'] = pd.to_datetime(bike_hour['dteday'])

bike_hour.describe()

"""### Missing Values"""

bike_hour.isnull().sum()

"""Tidak ada missing values

### Duplicated
"""

bike_hour.duplicated().sum()

"""Tidak ada duplikasi data

### Outliers
"""

numerical_cols = ['temp', 'atemp', 'hum', 'windspeed', 'casual', 'registered', 'cnt']

# Buat boxplot untuk tiap kolom numerik
plt.figure(figsize=(15, 10))
for i, col in enumerate(numerical_cols, 1):
    plt.subplot(3, 3, i)
    sns.boxplot(data=bike_hour, y=col)
    plt.title(f'Boxplot of {col}')
plt.tight_layout()
plt.show()

# Fungsi untuk mendeteksi outlier menggunakan metode IQR
def detect_outliers_iqr(data, column):
    Q1 = data[column].quantile(0.25)
    Q3 = data[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    outliers = data[(data[column] < lower_bound) | (data[column] > upper_bound)]
    return outliers


# Cek outlier untuk semua kolom numerik
for col in numerical_cols:
    outliers = detect_outliers_iqr(bike_hour, col)
    print(f"{col}: {len(outliers)} outliers")

"""Tidak ada outliers yang akan berpengaruh terhadap model

## Data Visualization
"""

plt.figure(figsize=(10,6))
sns.histplot(data=bike_hour, x='cnt', bins=40, kde=True)

"""Distribusi data cnt terlihat right-skewed atau menceng ke kanan, yang berarti sebagian besar jumlah penyewaan berada di angka rendah (0–200), dan hanya sedikit yang berada di angka tinggi (di atas 600). Hal ini menunjukkan bahwa penyewaan sepeda dalam jumlah besar lebih jarang terjadi dibanding penyewaan dalam jumlah kecil."""

plt.figure(figsize=(12,8))
corr_matrix = bike_hour.corr()
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f")

"""Berdasarkan heatmap, variabel yang memiliki korelasi paling kuat terhadap jumlah penyewaan sepeda (cnt) adalah registered (0.97) dan casual (0.69), yang memang secara logis membentuk cnt. Selain itu, jam (hr), temperatur (temp), dan feels-like temperature (atemp) juga menunjukkan korelasi positif moderat terhadap cnt. Sementara itu, kelembaban (hum) dan kecepatan angin (windspeed) memiliki korelasi negatif terhadap cnt, meskipun tidak terlalu kuat.

Kesimpulannya, faktor waktu, suhu, serta tipe pengguna (registered/casual) berpengaruh cukup besar terhadap jumlah penyewaan sepeda.

## Build Model
"""

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np

# Fitur dan target
X = bike_hour[['season', 'yr', 'mnth', 'hr', 'holiday', 'weekday',
             'workingday', 'weathersit', 'temp', 'atemp', 'hum', 'windspeed']]
y = bike_hour['cnt']

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Model
model = RandomForestRegressor(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# Prediksi dan evaluasi
y_pred = model.predict(X_test)
print("R² Score:", r2_score(y_test, y_pred))
print("RMSE:", np.sqrt(mean_squared_error(y_test, y_pred)))

"""Prediksi yang dihasilkan sangat tinggi dengan tingkat kesalahan menggunakan RMSE 42,07 tergolong kecil

Melakukan hyperparameter tuning menggunakan metode GridSearchCV atau RandomizedSearchCV, untuk memastikan model yang dihasilkan dapat memberikan prediksi yang paling optimal.
"""

from sklearn.model_selection import GridSearchCV

params = {
    'n_estimators': [100, 200],
    'max_depth': [10, 20, None],
    'min_samples_split': [2, 5],
}
grid = GridSearchCV(RandomForestRegressor(random_state=42), params, cv=3)
grid.fit(X_train, y_train)
print("Best Parameters:", grid.best_params_)

from sklearn.model_selection import cross_val_score
scores = cross_val_score(model, X, y, cv=5, scoring='r2')
print("Mean R² CV Score:", scores.mean())

"""## Perbandingan Random Forest dengan Model Lain"""

from sklearn.linear_model import LinearRegression
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error, r2_score
import numpy as np

# Model yang akan diuji
models = {
    'Random Forest': RandomForestRegressor(n_estimators=100, random_state=42),
    'Gradient Boosting': GradientBoostingRegressor(n_estimators=100, random_state=42),
    'Linear Regression': LinearRegression(),
    'KNN': KNeighborsRegressor(n_neighbors=5)
}

# Hasil evaluasi
for name, model in models.items():
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    r2 = r2_score(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    print(f"{name} - R²: {r2:.4f}, RMSE: {rmse:.2f}")

"""Random Forest menjadi model yang paling baik jadi keputusan menggunakan random forest sudah tepat"""

# Ambil model terbaik untuk visualisasi
best_model = RandomForestRegressor(n_estimators=100, random_state=42)
best_model.fit(X_train, y_train)
y_pred_best = best_model.predict(X_test)

plt.figure(figsize=(10,6))
plt.scatter(y_test, y_pred_best, alpha=0.3, color='teal')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
plt.xlabel('Actual cnt')
plt.ylabel('Predicted cnt')
plt.title('Random Forest - Actual vs Predicted')
plt.grid(True)
plt.tight_layout()
plt.show()

"""## Kesimpulan

Berdasarkan hasil evaluasi performa model dengan metrik R² dan Root Mean Square Error (RMSE), model Random Forest menunjukkan performa terbaik dibandingkan model lainnya. Dengan nilai R² sebesar 0.9441, Random Forest mampu menjelaskan sekitar 94,4% variabilitas dalam data target, yang mengindikasikan akurasi prediksi yang sangat tinggi. Selain itu, nilai RMSE sebesar 42.07 menunjukkan bahwa kesalahan prediksi dari model ini relatif rendah.

Model KNN dan Gradient Boosting juga menunjukkan performa yang cukup baik, namun masih berada di bawah Random Forest baik dari segi R² maupun RMSE. Sementara itu, Linear Regression menunjukkan performa paling rendah dengan R² hanya sebesar 0.3880 dan RMSE tertinggi sebesar 139.21, menandakan bahwa model linear kurang mampu menangkap kompleksitas data.

Dengan mempertimbangkan kedua metrik tersebut, Random Forest terbukti menjadi pilihan model yang paling tepat dan andal dalam memprediksi jumlah penyewaan sepeda pada dataset ini. Keunggulan Random Forest dalam menangani data non-linear serta kemampuannya dalam menghindari overfitting berkontribusi besar terhadap hasil prediksi yang akurat.
"""